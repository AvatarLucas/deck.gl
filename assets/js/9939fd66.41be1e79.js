"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[9811],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>k});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),p=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,s=r(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,k=u["".concat(c,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(k,l(l({ref:t},s),{},{components:n})):a.createElement(k,l({ref:t},s))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=m;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r[u]="string"==typeof e?e:i,l[1]=r;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(67294),i=n(86010);const o={tabItem:"tabItem_Ymn6"};function l(e){let{children:t,hidden:n,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(o.tabItem,l),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>w});var a=n(87462),i=n(67294),o=n(86010),l=n(12466),r=n(16550),c=n(91980),p=n(67392),s=n(50012);function u(e){return function(e){return i.Children.map(e,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:i}}=e;return{value:t,label:n,attributes:a,default:i}}))}function d(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=null!=t?t:u(n);return function(e){const t=(0,p.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function k(e){let{queryString:t=!1,groupId:n}=e;const a=(0,r.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=n?n:null}({queryString:t,groupId:n});return[(0,c._X)(o),(0,i.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);t.set(o,e),a.replace({...a.location,search:t.toString()})}),[o,a])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,o=d(e),[l,r]=(0,i.useState)((()=>function(e){var t;let{defaultValue:n,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+n+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return n}const i=null!=(t=a.find((e=>e.default)))?t:a[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:t,tabValues:o}))),[c,p]=k({queryString:n,groupId:a}),[u,g]=function(e){let{groupId:t}=e;const n=function(e){return e?"docusaurus.tab."+e:null}(t),[a,o]=(0,s.Nk)(n);return[a,(0,i.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:a}),b=(()=>{const e=null!=c?c:u;return m({value:e,tabValues:o})?e:null})();(0,i.useLayoutEffect)((()=>{b&&r(b)}),[b]);return{selectedValue:l,selectValue:(0,i.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error("Can't select invalid tab value="+e);r(e),p(e),g(e)}),[p,g,o]),tabValues:o}}var b=n(72389);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function h(e){let{className:t,block:n,selectedValue:r,selectValue:c,tabValues:p}=e;const s=[],{blockElementScrollPositionUntilNextRender:u}=(0,l.o5)(),d=e=>{const t=e.currentTarget,n=s.indexOf(t),a=p[n].value;a!==r&&(u(t),c(a))},m=e=>{var t;let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{var a;const t=s.indexOf(e.currentTarget)+1;n=null!=(a=s[t])?a:s[0];break}case"ArrowLeft":{var i;const t=s.indexOf(e.currentTarget)-1;n=null!=(i=s[t])?i:s[s.length-1];break}}null==(t=n)||t.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":n},t)},p.map((e=>{let{value:t,label:n,attributes:l}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,key:t,ref:e=>s.push(e),onKeyDown:m,onClick:d},l,{className:(0,o.Z)("tabs__item",y.tabItem,null==l?void 0:l.className,{"tabs__item--active":r===t})}),null!=n?n:t)})))}function v(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function f(e){const t=g(e);return i.createElement("div",{className:(0,o.Z)("tabs-container",y.tabList)},i.createElement(h,(0,a.Z)({},e,t)),i.createElement(v,(0,a.Z)({},e,t)))}function w(e){const t=(0,b.Z)();return i.createElement(f,(0,a.Z)({key:String(t)},e))}},58051:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>c,default:()=>k,frontMatter:()=>r,metadata:()=>p,toc:()=>u});var a=n(87462),i=(n(67294),n(3905)),o=n(74866),l=n(85162);const r={},c="Interactivity",p={unversionedId:"developer-guide/interactivity",id:"developer-guide/interactivity",title:"Interactivity",description:"Controlling the Camera",source:"@site/../docs/developer-guide/interactivity.md",sourceDirName:"developer-guide",slug:"/developer-guide/interactivity",permalink:"/docs/developer-guide/interactivity",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/interactivity.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Using Layers",permalink:"/docs/developer-guide/using-layers"},next:{title:"Coordinate Systems",permalink:"/docs/developer-guide/coordinate-systems"}},s={},u=[{value:"Controlling the Camera",id:"controlling-the-camera",level:2},{value:"Reset Camera Position",id:"reset-camera-position",level:3},{value:"Add Constraints to View State",id:"add-constraints-to-view-state",level:3},{value:"Externally Manage View State",id:"externally-manage-view-state",level:3},{value:"Advanced View Controls",id:"advanced-view-controls",level:3},{value:"Picking",id:"picking",level:2},{value:"What can be Picked?",id:"what-can-be-picked",level:3},{value:"Enabling Picking",id:"enabling-picking",level:3},{value:"Built-in Events",id:"built-in-events",level:3},{value:"The PickingInfo Object",id:"the-pickinginfo-object",level:3},{value:"Example: Display a Tooltip for Hovered Object",id:"example-display-a-tooltip-for-hovered-object",level:3},{value:"Using the Built-In Tooltip",id:"using-the-built-in-tooltip",level:4},{value:"Rendering a Custom Tooltip",id:"rendering-a-custom-tooltip",level:4},{value:"Calling the Picking Engine Directly",id:"calling-the-picking-engine-directly",level:3},{value:"Under The Hood",id:"under-the-hood",level:3}],d={toc:u},m="wrapper";function k(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"interactivity"},"Interactivity"),(0,i.kt)("h2",{id:"controlling-the-camera"},"Controlling the Camera"),(0,i.kt)("p",null,"Out of the box, deck.gl offers viewport controllers that map keyboard, mouse or touch input to camera state change. The easiest way to enable pan/zoom/rotate of the visualization is to set the ",(0,i.kt)("inlineCode",{parentName:"p"},"controller")," prop on ",(0,i.kt)("inlineCode",{parentName:"p"},"Deck")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"<DeckGL>")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," along with an ",(0,i.kt)("inlineCode",{parentName:"p"},"initialViewState")," object that defines the initial camera settings:"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck} from '@deck.gl/core';\n\nconst INITIAL_VIEW_STATE = {\n  longitude: -122.4,\n  latitude: 37.8,\n  zoom: 12,\n  pitch: 0,\n  bearing: 0\n};\n\nconst deckInstance = new Deck({\n  initialViewState: INITIAL_VIEW_STATE,\n  controller: true\n});\n"))),(0,i.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {Deck, MapViewState} from '@deck.gl/core';\n\nconst INITIAL_VIEW_STATE: MapViewState = {\n  longitude: -122.4,\n  latitude: 37.8,\n  zoom: 12,\n  pitch: 0,\n  bearing: 0\n};\n\nconst deckInstance = new Deck({\n  initialViewState: INITIAL_VIEW_STATE,\n  controller: true\n});\n"))),(0,i.kt)(l.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import React from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {MapViewState} from '@deck.gl/core';\n\nconst INITIAL_VIEW_STATE: MapViewState = {\n  longitude: -122.4,\n  latitude: 37.8,\n  zoom: 12,\n  pitch: 0,\n  bearing: 0\n};\n\nfunction App() {\n  return <DeckGL\n    initialViewState={INITIAL_VIEW_STATE}\n    controller\n  />;\n}\n")))),(0,i.kt)("p",null,"You can also selectively enable/disable certain controller features:"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const deckInstance = new Deck({\n  initialViewState: INITIAL_VIEW_STATE,\n  controller: {doubleClickZoom: false, touchRotate: true}\n});\n"))),(0,i.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const deckInstance = new Deck({\n  initialViewState: INITIAL_VIEW_STATE,\n  controller: {doubleClickZoom: false, touchRotate: true}\n});\n"))),(0,i.kt)(l.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"  return <DeckGL\n    initialViewState={INITIAL_VIEW_STATE}\n    controller={{doubleClickZoom: false, touchRotate: true}}\n  />;\n")))),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/controller"},"Controller")," for all options."),(0,i.kt)("h3",{id:"reset-camera-position"},"Reset Camera Position"),(0,i.kt)("p",null,"An application can reset the camera state by supplying a new ",(0,i.kt)("inlineCode",{parentName:"p"},"initialViewState")," object at any time:"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck, FlyToInterpolator} from '@deck.gl/core';\n\nconst CITIES = {\n  SF: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 10\n  },\n  NYC: {\n    longitude: -74.0,\n    latitude: 40.7,\n    zoom: 10\n  }\n}\n\nconst deckInstance = new Deck({\n  initialViewState: CITIES.SF,\n  controller: true\n});\n\nfor (const button of document.querySelectorAll('button')) {\n  button.onclick = () => flyToCity(button.id);\n}\n\nfunction flyToCity(name) {\n  deckInstance.setProps({\n    initialViewState: {\n      ...CITIES[name],\n      transitionInterpolator: new FlyToInterpolator({speed: 2}),\n      transitionDuration: 'auto'\n    }\n  })\n}\n"))),(0,i.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {Deck, MapViewState, FlyToInterpolator} from '@deck.gl/core';\n\nconst CITIES: {[name: string]: MapViewState} = {\n  SF: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 10\n  },\n  NYC: {\n    longitude: -74.0,\n    latitude: 40.7,\n    zoom: 10\n  }\n}\n\nconst deckInstance = new Deck({\n  initialViewState: CITIES.SF,\n  controller: true\n});\n\nfor (const button of document.querySelectorAll('button')) {\n  (button as HTMLButtonElement).onclick = () => flyToCity(button.id);\n}\n\nfunction flyToCity(name: string) {\n  deckInstance.setProps({\n    initialViewState: {\n      ...CITIES[name],\n      transitionInterpolator: new FlyToInterpolator({speed: 2}),\n      transitionDuration: 'auto'\n    }\n  })\n}\n"))),(0,i.kt)(l.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import React, {useState, useCallback} from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {MapViewState, FlyToInterpolator} from '@deck.gl/core';\n\nconst CITIES: {[name: string]: MapViewState} = {\n  SF: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 10\n  },\n  NYC: {\n    longitude: -74.0,\n    latitude: 40.7,\n    zoom: 10\n  }\n}\n\nfunction App() {\n  const [initialViewState, setInitialViewState] = useState<MapViewState>(CITIES.SF);\n\n  const flyToCity = useCallback(evt => {\n    setInitialViewState({\n      ...CITIES[evt.target.id],\n      transitionInterpolator: new FlyToInterpolator({speed: 2}),\n      transitionDuration: 'auto'\n    });\n  }, [])\n\n  return <>\n    <DeckGL\n      initialViewState={initialViewState}\n      controller\n    />;\n    {Object.keys(CITIES).map(name => <button id={name} onClick={flyToCity}>{name}</button>)}\n  </>;\n}\n")))),(0,i.kt)("p",null,"To learn more about animating a view state change, see ",(0,i.kt)("a",{parentName:"p",href:"/docs/developer-guide/animations-and-transitions#camera-transitions"},"view state transitions"),"."),(0,i.kt)("h3",{id:"add-constraints-to-view-state"},"Add Constraints to View State"),(0,i.kt)("p",null,"An application can optionally supply the ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/deck#onviewstatechange"},"onViewStateChange")," callback and manipulate the view state before it is used. The following example constrains the map in a bounding box:"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck} from '@deck.gl/core';\n\nconst bounds = [\n  [-123, 37], // South west corner\n  [-122, 38]  // North east corner\n];\n\nfunction applyViewStateConstraints(viewState) {\n  return {\n    ...viewState,\n    longitude: Math.min(bounds[1][0], Math.max(bounds[0][0], viewState.longitude)),\n    latitude: Math.min(bounds[1][1], Math.max(bounds[0][1], viewState.latitude))\n  };\n}\n\nnew Deck({\n  initialViewState: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 12\n  },\n  controller: true,\n  onViewStateChange: ({viewState}) => applyViewStateConstraints(viewState)\n});\n"))),(0,i.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {Deck, MapViewState} from '@deck.gl/core';\n\nconst bounds: [\n  [west: number, south: number],\n  [east: number, north: number]\n] = [\n  [-123, 37],\n  [-122, 38]\n];\n\nfunction applyViewStateConstraints(viewState: MapViewState): MapViewState {\n  return {\n    ...viewState,\n    longitude: Math.min(bounds[1][0], Math.max(bounds[0][0], viewState.longitude)),\n    latitude: Math.min(bounds[1][1], Math.max(bounds[0][1], viewState.latitude))\n  };\n}\n\nnew Deck({\n  initialViewState: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 12\n  },\n  controller: true,\n  onViewStateChange: ({viewState}) => applyViewStateConstraints(viewState)\n});\n"))),(0,i.kt)(l.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import React, {useCallback} from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {MapViewState} from '@deck.gl/core';\n\nfunction App({bounds}: {\n  bounds: [\n    [west: number, south: number],\n    [east: number, north: number]\n  ] \n}) {\n  const applyViewStateConstraints = useCallback((viewState: MapViewState) => ({\n    ...viewState,\n    longitude: Math.min(bounds[1][0], Math.max(bounds[0][0], viewState.longitude)),\n    latitude: Math.min(bounds[1][1], Math.max(bounds[0][1], viewState.latitude))\n  }), [bounds]);\n\n  return <DeckGL\n    initialViewState={{\n      longitude: -122.4,\n      latitude: 37.8,\n      zoom: 12\n    }}\n    controller\n    onViewStateChange={({viewState}) => applyViewStateConstraints(viewState)}\n  />;\n}\n")))),(0,i.kt)("h3",{id:"externally-manage-view-state"},"Externally Manage View State"),(0,i.kt)("p",null,"For more flexibility you can maintain the view state yourself and pass it in to deck.gl via the ",(0,i.kt)("inlineCode",{parentName:"p"},"viewState")," parameter. This essentially makes ",(0,i.kt)("inlineCode",{parentName:"p"},"Deck"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"<DeckGL>")," a stateless component, and allows you to synchronize the view state between multiple components, e.g. via a Redux store. The following example shows the most basic form of doing so."),(0,i.kt)("p",null,"Note: Do not combine ",(0,i.kt)("inlineCode",{parentName:"p"},"initialViewState")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"viewState")," props. ",(0,i.kt)("inlineCode",{parentName:"p"},"viewState")," will always overwrite any internal state."),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck} from '@deck.gl/core';\n\nconst deckInstance = new Deck({\n  viewState: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 12\n  },\n  controller: true,\n  onViewStateChange: ({viewState}) => {\n    deckInstance.setProps({viewState})\n  }\n});\n"))),(0,i.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {Deck} from '@deck.gl/core';\n\nconst deckInstance = new Deck({\n  viewState: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 12\n  },\n  controller: true,\n  onViewStateChange: ({viewState}) => {\n    deckInstance.setProps({viewState})\n  }\n});\n"))),(0,i.kt)(l.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import React, {useState} from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {MapViewState} from '@deck.gl/core';\n\nfunction App() {\n  const [viewState, setViewState] = useState<MapViewState>({\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 12\n  });\n\n  return <DeckGL\n    viewState={viewState}\n    controller\n    onViewStateChange={e => setViewState(e.viewState)}\n  />;\n}\n")))),(0,i.kt)("h3",{id:"advanced-view-controls"},"Advanced View Controls"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Alternative views such as OrbitView, FirstPersonView, and using multiple views such as VR, minimap: ",(0,i.kt)("a",{parentName:"li",href:"/docs/developer-guide/views"},"Views and Projections")),(0,i.kt)("li",{parentName:"ul"},"Implement a custom controller: ",(0,i.kt)("a",{parentName:"li",href:"/docs/api-reference/core/controller"},"Controller"))),(0,i.kt)("h2",{id:"picking"},"Picking"),(0,i.kt)("p",null,"Picking is the mechanism through which users interact with the geometries rendered by layers."),(0,i.kt)("p",null,"deck.gl includes a powerful picking engine that enables the application to precisely determine what object and layer is rendered on a certain pixel on the screen. This picking engine can either be called directly by an application (which is then typically implementing its own event handling), or it can be called automatically by the basic built-in event handling in deck.gl."),(0,i.kt)("h3",{id:"what-can-be-picked"},"What can be Picked?"),(0,i.kt)("p",null,'The picking engine identifies which object in which layer is at the given coordinates. While usually intuitive, what constitutes a pickable "object" is defined by each layer. Typically, it corresponds to one of the data entries that is passed in via ',(0,i.kt)("inlineCode",{parentName:"p"},"prop.data"),". For example, in ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/layers/scatterplot-layer"},"Scatterplot Layer"),", an object is an element in the ",(0,i.kt)("inlineCode",{parentName:"p"},"props.data")," array that is used to render one circle. In ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/layers/geojson-layer"},"GeoJson Layer"),", an object is a GeoJSON feature in the ",(0,i.kt)("inlineCode",{parentName:"p"},"props.data")," feature collection that is used to render one point, path or polygon."),(0,i.kt)("p",null,"Because the picking engine uses 8-bit RGBA colors to encode object and layer index, there is a limit of ",(0,i.kt)("inlineCode",{parentName:"p"},"255 - 1")," layers and ",(0,i.kt)("inlineCode",{parentName:"p"},"255 * 255 * 255 - 1")," objects per layer that can be picked at the same time. While deck.gl can easily create more than 254 layers (e.g. with tiled data), the picking process is smart about excluding layers that do not overlap with the queried pixel, so this limit is unlikely a problem in normal circumstances. If your app does hit this limit, it can be circumvented by ",(0,i.kt)("a",{parentName:"p",href:"#calling-the-picking-engine-directly"},"calling the picking engine directly")," with multiple batches of layers."),(0,i.kt)("p",null,"At the moment, the picking mechanism does not work for objects that are offscreen."),(0,i.kt)("h3",{id:"enabling-picking"},"Enabling Picking"),(0,i.kt)("p",null,"Picking can be enabled or disabled on a layer-by-layer basis. To enable picking on a layer, set its ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer#pickable"},(0,i.kt)("inlineCode",{parentName:"a"},"pickable"))," prop to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". This value is ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," by default."),(0,i.kt)("h3",{id:"built-in-events"},"Built-in Events"),(0,i.kt)("p",null,"For applications that have basic event handling needs, deck.gl has built-in support for handling selected pointer events. When the application registers callbacks, deck.gl automatically tracks these events, runs the picking engine and invokes the callbacks with the resulting ",(0,i.kt)("inlineCode",{parentName:"p"},"PickingInfo")," object."),(0,i.kt)("p",null,"The following event handlers are supported:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"onHover")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"onClick")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"onDragStart")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"onDrag")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"onDragEnd"))),(0,i.kt)("p",null,"A event handler function is called with two parameters: ",(0,i.kt)("inlineCode",{parentName:"p"},"info")," that contains information about the object being interacted with, and ",(0,i.kt)("inlineCode",{parentName:"p"},"event")," that contains the pointer event."),(0,i.kt)("p",null,"There are two ways to subscribe to the built-in picking event handling:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Specify callbacks for each pickable layer by passing ",(0,i.kt)("a",{parentName:"li",href:"/docs/api-reference/core/layer#interaction-properties"},"event handler props"),":")),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {ScatterplotLayer} from '@deck.gl/layers';\n\nconst layer = new ScatterplotLayer({\n  data: [\n    {position: [-122.45, 37.78]}\n  ],\n  getPosition: d => d.position,\n  getRadius: 1000,\n  getFillColor: [255, 255, 0],\n  // Required to enable picking\n  pickable: true\n  // Callback when the pointer enters or leaves an object\n  onHover: (info, event) => console.log('Hovered:', info, event),\n  // Callback when the pointer clicks on an object\n  onClick: (info, event) => console.log('Clicked:', info, event)\n});\n"))),(0,i.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {PickingInfo} from '@deck.gl/core';\nimport {MjolnirEvent} from 'mjolnir.js';\nimport {ScatterplotLayer} from '@deck.gl/layers';\n\ntype DataType = {\n  position: [longitude: number, latitude: number];\n};\n\nconst layer = new ScatterplotLayer<DataType>({\n  data: [\n    {position: [-122.45, 37.78]}\n  ],\n  getPosition: (d: DataType) => d.position,\n  getRadius: 1000,\n  getFillColor: [255, 255, 0],\n  // Required to enable picking\n  pickable: true\n  // Callback when the pointer enters or leaves an object\n  onHover: (info: PickingInfo<DataType>, event: MjolnirEvent) => console.log('Hovered:', info, event),\n  // Callback when the pointer clicks on an object\n  onClick: (info: PickingInfo<DataType>, event: MjolnirEvent) => console.log('Clicked:', info, event)\n});\n")))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Specify callbacks for all pickable layers by setting ",(0,i.kt)("a",{parentName:"li",href:"/docs/api-reference/react/deckgl#event-callbacks"},"event handler props")," of the ",(0,i.kt)("inlineCode",{parentName:"li"},"Deck"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"DeckGL")," component:")),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck} from '@deck.gl/core';\n\nnew Deck({\n  // ...\n  // Callback when the pointer enters or leaves an object in any pickable layer\n  onHover: (info, event) => console.log('Hovered:', info, event),\n  // Callback when the pointer clicks on an object in any pickable layer\n  onClick: (info, event) => console.log('Clicked:', info, event)\n})\n"))),(0,i.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {Deck, PickingInfo} from '@deck.gl/core';\nimport {MjolnirEvent} from 'mjolnir.js';\n\nnew Deck({\n  // ...\n  // Callback when the pointer enters or leaves an object in any pickable layer\n  onHover: (info: PickingInfo, event: MjolnirEvent) => console.log('Hovered:', info, event),\n  // Callback when the pointer clicks on an object in any pickable layer\n  onClick: (info: PickingInfo, event: MjolnirEvent) => console.log('Clicked:', info, event)\n})\n"))),(0,i.kt)(l.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import React, {useCallback} from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {Deck, PickingInfo} from '@deck.gl/core';\nimport {MjolnirEvent} from 'mjolnir.js';\n\nfunction App() {\n  // Callback when the pointer enters or leaves an object in any pickable layer\n  const onHover = useCallback((info: PickingInfo, event: MjolnirEvent) => {\n    console.log('Hovered:', info, event);\n  }, []);\n  // Callback when the pointer clicks on an object in any pickable layer\n  const onClick = useCallback((info: PickingInfo, event: MjolnirEvent) => {\n    console.log('Clicked:', info, event);\n  }, []);\n\n  return <DeckGL\n    // ...\n    onHover={onHover}\n    onClick={onClick}\n  />;\n}\n")))),(0,i.kt)("p",null,"Picking events are triggered based on ",(0,i.kt)("em",{parentName:"p"},"pickable objects"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"click")," event is triggered every time the pointer clicked on an object in a pickable layer."),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"hover")," event is triggered every time the hovered object of a pickable layer changes.")),(0,i.kt)("p",null,"When an event is fired, the ",(0,i.kt)("inlineCode",{parentName:"p"},"onHover")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"onClick")," callback of the affected layer is called first. If the callback returns a truthy value, the event is marked as handled. Otherwise, the event will bubble up to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Deck"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"DeckGL")," canvas and be visible to its ",(0,i.kt)("inlineCode",{parentName:"p"},"onHover")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"onClick")," callbacks."),(0,i.kt)("h3",{id:"the-pickinginfo-object"},"The PickingInfo Object"),(0,i.kt)("p",null,'The picking engine returns "picking info" objects which contains a variety of fields describing what layer and object was picked.'),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Key"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"picked")),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"Whether something was found under the pointer. This can be a more reliable test than ",(0,i.kt)("inlineCode",{parentName:"td"},"object")," because ",(0,i.kt)("inlineCode",{parentName:"td"},"object")," may be ",(0,i.kt)("inlineCode",{parentName:"td"},"null")," for certain layer and data types.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"index")),(0,i.kt)("td",{parentName:"tr",align:null},"number"),(0,i.kt)("td",{parentName:"tr",align:null},"The index of the object in the layer that was picked.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"layer")),(0,i.kt)("td",{parentName:"tr",align:null},"Layer"),(0,i.kt)("td",{parentName:"tr",align:null},"The top-level layer that the picked object belongs to. Only layers with the ",(0,i.kt)("inlineCode",{parentName:"td"},"pickable")," prop set to true can be picked.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sourceLayer")),(0,i.kt)("td",{parentName:"tr",align:null},"Layer"),(0,i.kt)("td",{parentName:"tr",align:null},"The immediate layer that rendered the picked pixel. This would be different from ",(0,i.kt)("inlineCode",{parentName:"td"},"layer")," if ",(0,i.kt)("inlineCode",{parentName:"td"},"layer")," is a ",(0,i.kt)("a",{parentName:"td",href:"/docs/api-reference/core/composite-layer"},"CompositeLayer"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"object")),(0,i.kt)("td",{parentName:"tr",align:null},"any"),(0,i.kt)("td",{parentName:"tr",align:null},"The object that was picked. This is typically an element from the layer's ",(0,i.kt)("inlineCode",{parentName:"td"},"props.data")," array, but can vary from layer to layer. This field is usually only present when picking from layers where ",(0,i.kt)("inlineCode",{parentName:"td"},"props.data")," ",(0,i.kt)("a",{parentName:"td",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray#description"},"is an array"),", unless indicated otherwise in the layer's documentation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"x")),(0,i.kt)("td",{parentName:"tr",align:null},"number"),(0,i.kt)("td",{parentName:"tr",align:null},"Mouse position x relative to the viewport.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"y")),(0,i.kt)("td",{parentName:"tr",align:null},"number"),(0,i.kt)("td",{parentName:"tr",align:null},"Mouse position y relative to the viewport.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"coordinate")),(0,i.kt)("td",{parentName:"tr",align:null},"number[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Corresponding point of the mouse position in the coordinate system of the layer. When using the built-in callbacks, this coordinate is 2D, assuming z=0 (i.e. on sea level in a geospatial dataset). You may optionally acquire a 3D position with a performance overhead by ",(0,i.kt)("a",{parentName:"td",href:"#calling-the-picking-engine-directly"},"calling the picking engine directly"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"viewport")),(0,i.kt)("td",{parentName:"tr",align:null},"Viewport"),(0,i.kt)("td",{parentName:"tr",align:null},"The viewport that the picked object belongs to.")))),(0,i.kt)("p",null,"Remarks:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Specific deck.gl layers, such as the ",(0,i.kt)("inlineCode",{parentName:"li"},"BitmapLayer")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"TileLayer"),", may add additional fields to the picking info object. Check the documentation of each layer."),(0,i.kt)("li",{parentName:"ul"},"Limitation when using multiple views: ",(0,i.kt)("inlineCode",{parentName:"li"},"viewport")," could potentially be misidentified if two views that contain the picked layer also overlap with each other and do not clear the background.")),(0,i.kt)("h3",{id:"example-display-a-tooltip-for-hovered-object"},"Example: Display a Tooltip for Hovered Object"),(0,i.kt)("h4",{id:"using-the-built-in-tooltip"},"Using the Built-In Tooltip"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Deck")," automatically renders a tooltip if the ",(0,i.kt)("inlineCode",{parentName:"p"},"getTooltip")," callback is supplied:"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck} from '@deck.gl/core';\nimport {ScatterplotLayer} from '@deck.gl/layers';\n\n// Callback to populate the default tooltip with content\nfunction getTooltip({object}) {\n  return object && object.message;\n}\n\nconst deckInstance = new Deck({\n  initialViewState: {\n    longitude: -122.45,\n    latitude: 37.78,\n    zoom: 12\n  },\n  controller: true,\n  layers: [\n    new ScatterplotLayer({\n      data: [\n        {position: [-122.45, 37.78], message: 'Hover over me'}\n      ],\n      getPosition: d => d.position,\n      getRadius: 1000,\n      getFillColor: [255, 255, 0],\n      // Required to enable picking\n      pickable: true\n    })\n  ],\n  getTooltip\n});\n"))),(0,i.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {Deck, PickingInfo} from '@deck.gl/core';\nimport {ScatterplotLayer} from '@deck.gl/layers';\n\ntype DataType = {\n  position: [longitude: number, latitude: number];\n  message: string;\n};\n\n// Callback to populate the default tooltip with content\nfunction getTooltip({object}: PickingInfo<DataType>) {\n  return object && object.message;\n}\n\nconst deckInstance = new Deck({\n  initialViewState: {\n    longitude: -122.45,\n    latitude: 37.78,\n    zoom: 12\n  },\n  controller: true,\n  layers: [\n    new ScatterplotLayer<DataType>({\n      data: [\n        {position: [-122.45, 37.78], message: 'Hover over me'}\n      ],\n      getPosition: (d: DataType) => d.position,\n      getRadius: 1000,\n      getFillColor: [255, 255, 0],\n      // Required to enable picking\n      pickable: true\n    })\n  ],\n  getTooltip\n});\n"))),(0,i.kt)(l.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import React, {useCallback} from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {PickingInfo} from '@deck.gl/core';\nimport {ScatterplotLayer} from '@deck.gl/layers';\n\ntype DataType = {\n  position: [longitude: number, latitude: number];\n  message: string;\n};\n\nfunction App() {\n  const layers = [\n    new ScatterplotLayer<DataType>({\n      data: [\n        {position: [-122.45, 37.78], message: 'Hover over me'}\n      ],\n      getPosition: (d: DataType) => d.position,\n      getRadius: 1000,\n      getFillColor: [255, 255, 0],\n      // Required to enable picking\n      pickable: true\n    })\n  ];\n\n  // Callback to populate the default tooltip with content\n  const getTooltip = useCallback(({object}: PickingInfo<DataType>) => {\n    return object && object.message;\n  }, []);\n\n  return <DeckGL\n    initialViewState={{\n      longitude: -122.45,\n      latitude: 37.78,\n      zoom: 12\n    }}\n    controller\n    layers={layers}\n    getTooltip={getTooltip}\n  />\n}\n")))),(0,i.kt)("p",null,"It receives a picking info object and returns the content of the tooltip. To customize the tooltip further, return an object instead:"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function getTooltip({object}) {\n  return object && {\n    html: `<h2>Message:</h2> <div>${object.message}</div>`,\n    style: {\n      backgroundColor: '#f00',\n      fontSize: '0.8em'\n    }\n  };\n}\n"))),(0,i.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function getTooltip({object}: PickingInfo<DataType>) {\n  return object && {\n    html: `<h2>Message:</h2> <div>${object.message}</div>`,\n    style: {\n      backgroundColor: '#f00',\n      fontSize: '0.8em'\n    }\n  };\n}\n"))),(0,i.kt)(l.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const getTooltip = useCallback(({object}: PickingInfo<DataType>) => {\n  return object && {\n    html: `<h2>Message:</h2> <div>${object.message}</div>`,\n    style: {\n      backgroundColor: '#f00',\n      fontSize: '0.8em'\n    }\n  };\n}, []);\n")))),(0,i.kt)("p",null,"For a range of options, see ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/deck#gettooltip"},"getTooltip")," documentation."),(0,i.kt)("h4",{id:"rendering-a-custom-tooltip"},"Rendering a Custom Tooltip"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck} from '@deck.gl/core';\nimport {ScatterplotLayer} from '@deck.gl/layers';\n\nconst tooltip = document.createElement('div');\ntooltip.style.position = 'absolute';\ntooltip.style.zIndex = 1;\ntooltip.style.pointerEvents = 'none';\ndocument.body.append(tooltip);\n\nfunction updateTooltip({object, x, y}) {\n  if (object) {\n    tooltip.style.display = 'block';\n    tooltip.style.left = `${x}px`;\n    tooltip.style.top = `${y}px`;\n    tooltip.innerText = object.message;\n  } else {\n    tooltip.style.display = 'none';\n  }\n}\n\nconst deckInstance = new Deck({\n  initialViewState: {\n    longitude: -122.45,\n    latitude: 37.78,\n    zoom: 12\n  },\n  controller: true,\n  layers: [\n    new ScatterplotLayer({\n      data: [\n        {position: [-122.45, 37.78], message: 'Hover over me'}\n      ],\n      getPosition: d => d.position,\n      getRadius: 1000,\n      getFillColor: [255, 255, 0],\n      // Required to enable picking\n      pickable: true,\n      // Update tooltip position and content\n      onHover: updateTooltip\n    })\n  ]\n});\n"))),(0,i.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {Deck, PickingInfo} from '@deck.gl/core';\nimport {ScatterplotLayer} from '@deck.gl/layers';\n\ntype DataType = {\n  position: [longitude: number, latitude: number];\n  message: string;\n};\n\nconst tooltip: HTMLDivElement = document.createElement('div');\ntooltip.style.position = 'absolute';\ntooltip.style.zIndex = 1;\ntooltip.style.pointerEvents = 'none';\ndocument.body.append(tooltip);\n\nfunction updateTooltip({object, x, y}: PickingInfo<DataType>) {\n  if (object) {\n    tooltip.style.display = 'block';\n    tooltip.style.left = `${x}px`;\n    tooltip.style.top = `${y}px`;\n    tooltip.innerText = object.message;\n  } else {\n    tooltip.style.display = 'none';\n  }\n}\n\nconst deckInstance = new Deck({\n  initialViewState: {\n    longitude: -122.45,\n    latitude: 37.78,\n    zoom: 12\n  },\n  controller: true,\n  layers: [\n    new ScatterplotLayer<DataType>({\n      data: [\n        {position: [-122.45, 37.78], message: 'Hover over me'}\n      ],\n      getPosition: (d: DataType) => d.position,\n      getRadius: 1000,\n      getFillColor: [255, 255, 0],\n      // Required to enable picking\n      pickable: true,\n      // Update tooltip position and content\n      onHover: updateTooltip\n    })\n  ]\n});\n"))),(0,i.kt)(l.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import React, {useState} from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {PickingInfo} from '@deck.gl/core';\nimport {ScatterplotLayer} from '@deck.gl/layers';\n\ntype DataType = {\n  position: [longitude: number, latitude: number];\n  message: string;\n};\n\nconst tooltipStyle: React.CSSProperties = {\n  position: 'absolute',\n  zIndex: 1,\n  pointerEvents: 'none'\n};\n\nfunction App() {\n  const [hoverInfo, setHoverInfo] = useState<PickingInfo<DataType>>();\n\n  const layers = [\n    new ScatterplotLayer<DataType>({\n      data: [\n        {position: [-122.45, 37.78], message: 'Hover over me'}\n      ],\n      getPosition: (d: DataType) => d.position,\n      getRadius: 1000,\n      getFillColor: [255, 255, 0],\n      // Required to enable picking\n      pickable: true,\n      // Update app state\n      onHover: info => setHoverInfo(info)\n    })\n  ];\n\n  return <DeckGL\n    initialViewState={{\n      longitude: -122.45,\n      latitude: 37.78,\n      zoom: 12\n    }}\n    controller\n    layers={layers} >\n      {hoverInfo.object && (\n        <div style={{...tooltipStyle, left: hoverInfo.x, top: hoverInfo.y}}>\n          { hoverInfo.object.message }\n        </div>\n      )}\n  </DeckGL>;\n}\n")))),(0,i.kt)("h3",{id:"calling-the-picking-engine-directly"},"Calling the Picking Engine Directly"),(0,i.kt)("p",null,"While the default events handle most of the use cases, sometimes applications need more control over when and how picking is performed."),(0,i.kt)("p",null,"The picking engine is exposed through the ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/deck#pickobject"},(0,i.kt)("inlineCode",{parentName:"a"},"Deck.pickObject"))," and ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/deck#pickobjects"},(0,i.kt)("inlineCode",{parentName:"a"},"Deck.pickObjects"))," methods. These methods allow you to query what layers and objects within those layers are under a specific point or within a specified rectangle. They return ",(0,i.kt)("inlineCode",{parentName:"p"},"PickingInfo")," objects as described above."),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {Deck} from '@deck.gl/core';\n\nconst deckInstance = new Deck({\n  // ...\n  onClick: ({x, y}) => {\n    // Query up to 5 overlapping objects under the pointer\n    const pickInfos = deckInstance.pickMultipleObjects({x, y, radius: 1, depth: 5});\n    console.log(pickInfo);\n  }\n});\n"))),(0,i.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {Deck, PickingInfo} from '@deck.gl/core';\n\nconst deckInstance = new Deck({\n  // ...\n  onClick: ({x, y}: PickingInfo) => {\n    // Query up to 5 overlapping objects under the pointer\n    const pickInfos: PickingInfo[] = deckInstance.pickMultipleObjects({x, y, radius: 1, depth: 5});\n    console.log(pickInfo);\n  }\n});\n"))),(0,i.kt)(l.Z,{value:"react",label:"React",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import React, {useRef, useCallback} from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {PickingInfo} from '@deck.gl/core';\n\nfunction App() {\n  const deckRef = useRef<DeckGL>();\n\n  const onClick = useCallback((evt: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    // Get mouse position relative to the containing div\n    const containerRect = evt.currentTarget.getBoundingClientRect();\n    const x = evt.clientX - containerRect.left;\n    const y = evt.clientY = containerRect.top;\n    // Query up to 5 overlapping objects under the pointer\n    const pickInfos: PickingInfo[] = deckRef.current?.pickMultipleObjects({x, y, radius: 1, depth: 5});\n    console.log(pickInfo);\n  }, [])\n\n  return <div onClick={onClick}>\n    <DeckGL ref={deckRef} ... />\n  </div>;\n}\n")))),(0,i.kt)("p",null,"Also note that by directly calling ",(0,i.kt)("inlineCode",{parentName:"p"},"queryObject"),", integrating deck.gl into an existing application often becomes easier since you don't have to change the application's existing approach to event handling."),(0,i.kt)("h3",{id:"under-the-hood"},"Under The Hood"),(0,i.kt)("p",null,"If you are using the core layers, all has been taken care of."),(0,i.kt)("p",null,"If you are implementing a custom layer, read more about\n",(0,i.kt)("a",{parentName:"p",href:"/docs/developer-guide/custom-layers/picking"},"how picking is implemented"),"."))}k.isMDXComponent=!0}}]);